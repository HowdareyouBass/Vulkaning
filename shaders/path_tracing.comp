#version 450

layout (local_size_x = 32, local_size_y = 32) in;

layout (rgba8, set = 0, binding = 0) uniform image2D draw_img;

struct Sphere 
{
    vec3 center;
    float radius;
};
layout (set = 0, binding = 1) buffer SphereBuffer
{
    Sphere spheres[];
};

struct Ray
{
    vec3 A;
    vec3 B;
};

bool hit_sphere(Sphere s, Ray r)
{
    float a = dot(r.B, r.B);
    float b = 2*dot(r.B, r.A - s.center);
    float c = dot(r.A - s.center, r.A - s.center) - s.radius*s.radius;

    float discriminant = b*b - 4*a*c;

    return (discriminant >= 0);
}

layout (push_constant) uniform constants
{
    int sphere_count;
} pc;

const Ray test_ray = Ray(vec3(2.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));

void main()
{
    ivec2 texel_coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 img_size = imageSize(draw_img);

    if (texel_coord.x < img_size.x && texel_coord.y < img_size.y)
    {
        Ray forward = Ray(vec3(float(texel_coord.x)/float(img_size.x) * 2 - 1, float(texel_coord.y)/float(img_size.y) * 2 - 1, 0.0), vec3(0.0, 0.0, 1.0));
        imageStore(draw_img, texel_coord, vec4(0.1, 0.1, 0.1, 1.0));
        for (int i = 0; i < pc.sphere_count; i++)
        {
            if (hit_sphere(spheres[i], forward))
            {
                imageStore(draw_img, texel_coord, vec4(1.0, 0.0, 0.0, 1.0));
            }
        }
    }
}
